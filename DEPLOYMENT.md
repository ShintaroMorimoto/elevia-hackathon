# Deployment Guide - Elevia OKR Application

This guide explains how to deploy the Elevia OKR application to Google Cloud Platform using **GitHub Actions CI/CD** with Terraform and automated container deployment.

## ðŸš€ CI/CD First Approach

This project uses **GitHub Actions for all deployments**. Manual commands are provided for reference only - all actual deployments should use the automated CI/CD pipeline.

## Prerequisites

Before deploying, ensure you have:

1. **Google Cloud Project** with billing enabled
2. **GitHub repository** for the code
3. **Local development environment** with:
   - Google Cloud SDK (`gcloud`)
   - Terraform (>= 1.0)
   - Node.js 20+
   - pnpm

## Infrastructure Overview

The deployment consists of:
- **Cloud SQL (PostgreSQL)** - Database with private IP
- **Cloud Run** - Application runtime with VPC access
- **VPC** - Private networking with connector
- **Artifact Registry** - Container images
- **Secret Manager** - Sensitive data (DB passwords, secrets)
- **GitHub Actions** - CI/CD pipeline with Workload Identity Federation

## Architecture

### Production Environment (Cloud Run)
- **Database Connection**: VPC direct connection to Cloud SQL private IP
- **Secret Management**: Secret Manager injection for DB_PASS and AUTH_SECRET
- **Security**: No exposed passwords, VPC-only database access

### Development Environment  
- **Database Connection**: Cloud SQL Proxy on localhost:5432
- **Configuration**: Individual environment variables from .env.local

## Step 1: Initial Setup

### 1.1 Clone and Configure

```bash
# Clone the repository
git clone <your-repo-url>
cd deploy-to-gcp

# Copy environment template
cp .env.template .env.local

# Edit .env.local with your values
```

### 1.2 Configure Environment Variables

Edit `.env.local`:

```bash
# Google Cloud Configuration
GOOGLE_CLOUD_PROJECT_ID=your-gcp-project-id
GOOGLE_CLOUD_PROJECT_NUMBER=123456789012
WORKLOAD_IDENTITY_POOL=github-actions
WORKLOAD_IDENTITY_PROVIDER=github
GITHUB_REPO=your-repo-name
GITHUB_OWNER=your-github-username

# Database Configuration
# Note: CLOUD_SQL_CONNECTION_NAME will be generated by Terraform after deployment
DB_USER=elevia_user
DB_PASS=your-secure-database-password-min-8-chars
DB_NAME=elevia_db

# NextAuth Configuration
NEXTAUTH_URL=https://your-domain.com  # Will be updated after deployment
NEXTAUTH_SECRET=your-32-char-secret-key

# AI Configuration
GOOGLE_VERTEX_PROJECT_ID=your-project-id
GOOGLE_VERTEX_LOCATION=asia-northeast1
```

### 1.3 Initialize Google Cloud Workload Identity (One-time Setup)

**Note**: This is a one-time setup that only needs to be run once per project.

```bash
# Make the init script executable and run
chmod +x ./scripts/init.sh && ./scripts/init.sh
```

This script configures:
- Workload Identity Federation for GitHub Actions
- Required Google Cloud APIs
- Service accounts and IAM permissions  
- GCS bucket for Terraform state management

**The script is idempotent** - running it multiple times is safe.

## Step 2: Configure GitHub Repository

### 2.1 Set Repository Variables

In your GitHub repository, go to Settings > Secrets and variables > Actions, and add these **Variables**:

```
GOOGLE_CLOUD_PROJECT_ID=your-gcp-project-id
GOOGLE_CLOUD_PROJECT_NUMBER=123456789012
WORKLOAD_IDENTITY_POOL=github-actions
WORKLOAD_IDENTITY_PROVIDER=github
```

### 2.2 Set Repository Secrets

âš ï¸ **IMPORTANT**: Secrets must be set in the **"Terraform" Environment** (not Repository Secrets)

1. Go to Settings > Environments
2. Click on **"Terraform"** environment (create if it doesn't exist)
3. Add these **Environment secrets**:

```
AUTH_SECRET=your-nextauth-secret-here    # NOTE: AUTH_SECRET not NEXTAUTH_SECRET
DB_USER=elevia_user
DB_PASS=your-secure-database-password
DB_NAME=elevia_db
```

**Critical Notes**:
- âœ… Use `AUTH_SECRET` (not `NEXTAUTH_SECRET`)
- âœ… Avoid special characters like `/`, `"`, `'` in secret values
- âœ… Set in "Terraform" Environment, not Repository Secrets
- âœ… Must match the `environment: Terraform` setting in terraform.yml

**Note**: These values will be automatically stored in Secret Manager by Terraform and injected into Cloud Run at runtime. You don't need to manually create secrets in Google Cloud Console.

### âš ï¸ Quick Configuration Checklist

Before running workflows, verify these critical settings:

**GitHub Environment "Terraform" Variables** âœ…
```bash
# Verify with: gh api repos/:owner/:repo/environments/Terraform/variables
GOOGLE_CLOUD_PROJECT_ID=your-project-id
GOOGLE_CLOUD_PROJECT_NUMBER=123456789012  
WORKLOAD_IDENTITY_POOL=github-test
WORKLOAD_IDENTITY_PROVIDER=github
```

**GitHub Environment "Terraform" Secrets** âœ…
```bash
# Verify with: gh api repos/:owner/:repo/environments/Terraform/secrets
AUTH_SECRET=your-secret-here    # NOT NEXTAUTH_SECRET
DB_USER=elevia_user
DB_PASS=your-password
DB_NAME=elevia_db
```

**Workload Identity Repository Setting** âœ…
```bash
# Verify with: gcloud iam workload-identity-pools providers describe github ...
# Should show: assertion.repository=='YourUsername/your-actual-repo-name'
```

## Step 3: Setup GitHub Actions Workflows

The deployment is fully automated through GitHub Actions using **Direct Workload Identity Federation**. Once the repository variables and secrets are configured, deployments happen automatically on push to main branch.

### 3.1 GitHub Actions Workflows Created

**PR Validation Workflow (`.github/workflows/pr-validation.yml`)**:
- âœ… **Early Feedback**: Fast quality checks on every pull request
- âœ… **Comprehensive Testing**: Lint, type check, unit tests, application build
- âœ… **Docker Build Validation**: Ensures Docker image builds successfully
- âœ… **No Redundancy**: Single workflow for all PR validation needs

**Infrastructure Workflow (`.github/workflows/terraform.yml`)**:
- âœ… **Direct Workload Identity Federation**: No service account needed for GitHub Actions authentication
- âœ… **Terraform Plan on PRs**: Automatic plan comments on pull requests  
- âœ… **Terraform Apply on Main**: Automatic infrastructure deployment on merge
- âœ… **30-minute timeout**: Handles Cloud SQL creation time

**Deployment Workflow (`.github/workflows/deploy.yml`)**:
- âœ… **Main Branch Only**: Triggers only on main branch push (no PR triggers)
- âœ… **No Test Duplication**: Focuses solely on deployment activities
- âœ… **Docker Build/Push**: Automatic container creation and push to Artifact Registry
- âœ… **Cloud Run Deployment**: Zero-downtime rolling deployment
- âœ… **Database Migration**: Automatic Drizzle migrations
- âœ… **Direct WIF Authentication**: Secure authentication without service account keys

**Workflow Optimization Benefits**:
- âœ… **No Duplication**: Each workflow has clear, separate responsibilities
- âœ… **Fast PR Feedback**: Quality checks complete quickly without heavy deployment steps
- âœ… **Resource Efficient**: Eliminates redundant test execution
- âœ… **Clear Separation**: Validation vs. deployment concerns properly separated

### 3.2 Terraform Configuration (Automated)

Terraform variables are managed through the GitHub Actions workflow. The `terraform.tfvars` file is automatically generated from repository secrets and variables.

**Key Terraform Improvements Already Applied**:
- âœ… **Timeout Configuration**: 30-minute timeouts for Cloud SQL operations
- âœ… **Dependency Management**: Explicit dependencies prevent race conditions  
- âœ… **API Corrections**: Uses correct `sqladmin.googleapis.com` API name
- âœ… **Direct Workload Identity Federation**: No service account keys for GitHub Actions

## Step 4: Deploy via GitHub Actions

### 4.1 Automated Deployment Process

The deployment process is **fully automated**:

1. **Push to main branch** triggers the deployment workflow
2. **GitHub Actions automatically**:
   - Runs tests and linting
   - Deploys infrastructure via Terraform (if changes detected)
   - Builds and pushes Docker image to Artifact Registry
   - Deploys to Cloud Run with Secret Manager integration
   - Runs database migrations automatically

### 4.2 Deployment Workflow Features

**Infrastructure Management**:
- âœ… **Direct Workload Identity Federation**: Secure authentication without service account keys
- âœ… Terraform plan on pull requests (with plan comments)
- âœ… Terraform apply on main branch merges
- âœ… 30-minute timeout handling for Cloud SQL
- âœ… Automatic dependency resolution

**Application Deployment**:
- âœ… **Direct WIF Authentication**: No service account keys needed
- âœ… Full CI pipeline (lint, test, build)
- âœ… Automated Docker build and push to Artifact Registry
- âœ… Zero-downtime Cloud Run deployment
- âœ… Automatic database migrations with Drizzle
- âœ… Secret Manager integration (no exposed credentials)
- âœ… VPC-only database access (production security)

**No manual intervention required** - the entire process is automated from code push to production deployment.

## Step 5: Database Setup (Automated)

### 5.1 Production Database Configuration

**Database setup is fully automated** through the GitHub Actions deployment:

- âœ… Cloud SQL PostgreSQL instance creation (with 30-minute timeout)
- âœ… Database and user creation via Terraform
- âœ… VPC-only access (no public IP)
- âœ… Secret Manager integration for credentials
- âœ… Automatic migrations during deployment

### 5.2 Local Development Setup

For local development, connect to the Cloud SQL instance:

```bash
# Install Cloud SQL Proxy
gcloud components install cloud-sql-proxy

# Get connection name from deployment outputs
terraform output cloud_sql_connection_name

# Start proxy for local development
cloud_sql_proxy -instances=YOUR_CONNECTION_NAME=tcp:5432

# Run development setup
pnpm run db:generate
pnpm run db:migrate
pnpm run dev
```

**Environment Detection**:
- **Development**: Uses Cloud SQL Proxy on localhost:5432
- **Production**: Uses VPC direct connection with Secret Manager

## Step 6: Verify Deployment (Automated)

### 6.1 Deployment Verification

**GitHub Actions automatically verifies**:
- âœ… Infrastructure deployment status
- âœ… Docker image build and push
- âœ… Cloud Run service health
- âœ… Database connectivity
- âœ… Application startup and readiness

### 6.2 Access Your Application

1. **Cloud Run URL**: Automatically provided in GitHub Actions logs
2. **Application Health**: Built-in health checks verify deployment
3. **Monitoring**: Cloud Logging and Monitoring automatically configured

**Manual verification commands** (optional):
```bash
# View deployment outputs
terraform output cloud_run_url

# Check service status
gcloud run services list --platform=managed

# View application logs
gcloud logs read --service=elevia --platform=managed
```

## Step 7: Custom Domain (Optional)

### 7.1 Configure Domain Mapping

```bash
# Map custom domain to Cloud Run
gcloud run domain-mappings create \
  --service=elevia \
  --domain=your-domain.com \
  --region=asia-northeast1
```

### 7.2 Update Environment Variables

Update `NEXTAUTH_URL` in your secrets to use the custom domain.

## Monitoring and Maintenance

### Database Backups

Cloud SQL automatically creates daily backups and supports point-in-time recovery.

### Logs and Monitoring

- **Application logs**: Available in Cloud Logging
- **Metrics**: Available in Cloud Monitoring
- **Error tracking**: Available in Error Reporting

### Updating the Application

1. Make code changes
2. Push to main branch
3. GitHub Actions will automatically deploy

### Scaling

Cloud Run automatically scales based on traffic. Adjust `max_instances` in Terraform if needed.

## Troubleshooting

### âš ï¸ Critical GitHub Actions Configuration Issues

#### 1. GitHub Environment Variables Not Recognized

**Issue**: GitHub Actions variables appear to be set but are empty in workflows.

**Root Cause**: GitHub has multiple places to store variables:
- **Repository Variables** (Settings > Secrets and variables > Actions > Variables tab)
- **Environment Variables** (Settings > Environments > [Environment Name] > Environment variables)

**Solution**: 
- âœ… **Ensure variables are set in the correct Environment**
- The workflow uses `environment: Terraform` (line 26 in terraform.yml)
- Variables must be set in the **"Terraform" Environment**, not "Configure Terraform" or Repository Variables
- **Verification**: Use `gh api repos/:owner/:repo/environments/Terraform/variables` to check

```bash
# Check which environments exist
gh api repos/:owner/:repo/environments

# Check variables in specific environment  
gh api repos/:owner/:repo/environments/Terraform/variables

# Should show your 4 required variables
```

**Required Variables in "Terraform" Environment**:
```
GOOGLE_CLOUD_PROJECT_ID=your-project-id
GOOGLE_CLOUD_PROJECT_NUMBER=123456789012
WORKLOAD_IDENTITY_POOL=github-test
WORKLOAD_IDENTITY_PROVIDER=github
```

#### 2. Workload Identity Federation Permission Errors

**Issue**: Authentication works but gets "unauthorized_client" or "repository not allowed" errors.

**Root Cause**: 
- Wrong repository name in Workload Identity Provider attribute condition
- Old permissions from previous repository names
- `init.sh` script has a bug in permission checking logic

**Solutions**:

**Check Current Attribute Condition**:
```bash
gcloud iam workload-identity-pools providers describe github \
  --workload-identity-pool=github-test \
  --location=global \
  --project=sandbox-morimoto-s1 \
  --format="value(attributeCondition)"
```

**Update Repository Name if Incorrect**:
```bash
gcloud iam workload-identity-pools providers update-oidc github \
  --workload-identity-pool=github-test \
  --location=global \
  --project=sandbox-morimoto-s1 \
  --attribute-condition="assertion.repository=='YourGitHubUsername/your-repo-name'"
```

**Re-run init.sh after fixing the script**:
```bash
# The init.sh script has been fixed for permission checking
./scripts/init.sh
```

#### 3. Secret Manager Variable Name Mismatches

**Issue**: `nextauth_secret = ""` (empty) in terraform.tfvars despite secrets being set.

**Root Causes**:
- Variable name mismatch: `NEXTAUTH_SECRET` vs `AUTH_SECRET`
- HEREDOC vs echo command variable expansion issues
- Special characters (like `/`) in secret values causing parsing errors

**Solutions**:

**Correct Secret Names** (set these in GitHub Environment "Terraform" Secrets):
```
AUTH_SECRET=your-nextauth-secret-here  # NOT NEXTAUTH_SECRET
DB_USER=elevia_user
DB_PASS=your-secure-password
DB_NAME=elevia_db
```

**Avoid Special Characters in Secrets**:
- Don't use `/`, `"`, `'`, `\` in AUTH_SECRET values
- Use base64 encoded values if needed: `openssl rand -base64 32`

#### 4. Terraform State Bucket Naming Inconsistency

**Issue**: "bucket doesn't exist" error during terraform init.

**Root Cause**: Naming convention mismatch between init.sh and deploy.yml:
- `init.sh` creates: `${PROJECT_ID}-terraform-state`
- `deploy.yml` initially expected: `terraform-state-${PROJECT_ID}`

**Solution**: Update deploy.yml to use consistent naming pattern.

```yaml
# âŒ Wrong - inconsistent with init.sh
terraform init \
  -backend-config="bucket=terraform-state-${{ vars.GOOGLE_CLOUD_PROJECT_ID }}" \

# âœ… Correct - matches init.sh pattern
terraform init \
  -backend-config="bucket=${{ vars.GOOGLE_CLOUD_PROJECT_ID }}-terraform-state" \
```

**Prevention**: Always verify bucket naming consistency between init.sh and CI/CD workflows.

#### 5. Terraform Format Issues with Generated Files

**Issue**: `terraform fmt -check` fails with "Missing newline after argument".

**Root Causes**:
- Generated terraform.tfvars missing final newline
- Single quotes preventing variable expansion in echo commands
- HEREDOC not handling special characters properly

**Solution**: Fixed in terraform.yml to:
- Use double quotes with escaped inner quotes
- Run `terraform fmt` after file generation
- Use echo commands instead of HEREDOC

#### 6. Branch Protection Rules and GitHub Pro Requirements

**Issue**: Cannot set up branch protection rules to prevent merging when workflows fail.

**Root Cause**: GitHub branch protection features require:
- **GitHub Pro subscription** for private repositories
- **Public repository** for free accounts

**Solutions**:

**Option A: Manual Process** (No GitHub Pro required):
1. Always check GitHub Actions status before merging PRs
2. Look for green checkmarks on all required workflows
3. Only merge when all checks pass

**Option B: Repository Settings** (Requires GitHub Pro or public repo):
1. Go to Settings > Branches
2. Add rule for `main` branch:
   - âœ… Require status checks to pass before merging
   - âœ… Require branches to be up to date before merging
   - Select required checks: `Terraform Infrastructure`, `Pull Request Validation`
   - âœ… Require pull request reviews before merging

**Option C: GitHub Actions Auto-merge** (Alternative):
```yaml
# Add to workflow to enable auto-merge only when all checks pass
- name: Enable auto-merge
  if: github.event_name == 'pull_request'
  run: gh pr merge --auto --merge "${{ github.event.pull_request.number }}"
  env:
    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

**Verification Commands**:
```bash
# Check current branch protection status
gh api repos/:owner/:repo/branches/main/protection

# List all workflow runs for a PR
gh run list --branch=your-pr-branch

# Check workflow status
gh run view --log
```

### Common Issues

1. **Permission Errors During Terraform Apply**
   
   **Error**: `Permission denied to enable service [cloudsql.googleapis.com]` or `Service 'cloudsql.googleapis.com' is an internal service; it cannot be used outside of its own organization.`
   
   **Cause**: This error occurs due to organization policy restrictions that limit which services can be enabled in the project.
   
   **Solutions**:
   
   **Option A: Contact Organization Administrator**
   - Contact your Google Cloud organization administrator to:
     - Enable Cloud SQL API at the organization level
     - Remove organization policy constraints that prevent API enablement
     - Grant appropriate permissions for the sandbox project
   
   **Option B: Use a Personal Google Cloud Project**
   - Create a new Google Cloud project using your personal Google account
   - Use that project for development/testing purposes
   - Update `.env.local` and `terraform.tfvars` with the new project ID
   
   **Option C: Alternative Architecture**
   - Modify the Terraform configuration to use external database services (like Supabase or AWS RDS)
   - Update the application to connect to external databases instead of Cloud SQL
   
   **Manual verification of current APIs**:
   ```bash
   # Check which APIs are currently enabled
   gcloud services list --enabled --project=sandbox-morimoto-s1
   
   # Check organization policies that might be blocking API enablement
   gcloud resource-manager org-policies list --project=sandbox-morimoto-s1
   ```
   
   **If APIs can be enabled manually through Console**:
   - Go to Google Cloud Console â†’ APIs & Services â†’ Library
   - Search for and enable each required API manually:
     - Cloud SQL Admin API
     - Compute Engine API
     - Cloud Run API
     - Artifact Registry API
     - VPC Access API
     - Service Networking API
   - Then retry: `terraform apply`

2. **Database Connection Errors**
   - **Production**: Check VPC connector configuration and Secret Manager access
   - **Development**: Ensure Cloud SQL Proxy is running on localhost:5432
   - Verify Cloud SQL instance is running: `gcloud sql instances list`
   - Check logs: `gcloud logs read --service=elevia --platform=managed`

2. **Secret Manager Issues**
   - Verify secrets exist: `gcloud secrets list`
   - Check Cloud Run service account has `secretmanager.secretAccessor` role
   - Ensure DB_PASS and AUTH_SECRET are properly set in Terraform

3. **Environment Detection Issues**
   - Check `K_SERVICE` environment variable is set in Cloud Run
   - Verify `NODE_ENV=production` in Cloud Run
   - Review database connection logs in Cloud Logging

4. **Build Failures**
   - Check Docker build logs in GitHub Actions
   - Verify all dependencies are installed (including @google-cloud/cloud-sql-connector)
   - Check for TypeScript/linting errors

5. **Permission Errors**
   - Verify Workload Identity Federation setup
   - Check service account permissions
   - Ensure GitHub variables/secrets are set correctly

### CI/CD Troubleshooting Best Practices

#### 7. Systematic CI/CD Debugging Approach

When CI/CD fails, follow this systematic debugging approach:

**Step 1: Identify the Failing Stage**
```bash
# Check recent workflow runs
gh run list --limit 10

# Get specific run details
gh run view <run-id>

# View logs for failed run
gh run view <run-id> --log
```

**Step 2: Analyze Error Patterns**
- **Authentication errors**: Check Workload Identity Federation setup
- **Resource not found**: Verify resource naming consistency
- **Permission denied**: Check IAM roles and bindings
- **Timeout errors**: Verify timeout settings (especially for Cloud SQL)

**Step 3: Common Debugging Commands**
```bash
# Check workflow file syntax
cat .github/workflows/deploy.yml | grep -A5 -B5 "bucket"

# Verify GitHub repository variables
gh variable list

# Verify GitHub repository secrets
gh secret list

# Check Google Cloud authentication
gcloud auth list
gcloud config get-value project

# Verify init.sh setup
ls -la gs://sandbox-morimoto-s1-terraform-state/
```

**Step 4: Fix and Test Cycle**
1. Identify root cause from logs
2. Fix configuration inconsistencies
3. Commit changes with descriptive message
4. Monitor new workflow execution
5. Repeat if necessary

**Step 5: Prevention Measures**
- Verify naming conventions between init.sh and workflows
- Test workflows in feature branches when possible
- Use repository variables consistently
- Document configuration dependencies

### Logs and Debugging

```bash
# View Cloud Run logs (shows database connection attempts)
gcloud logs read --service=elevia --platform=managed

# View recent logs with filter
gcloud logs read --service=elevia --platform=managed --limit=50 --format="table(timestamp,severity,textPayload)"

# Check Secret Manager access
gcloud secrets versions access latest --secret=elevia-db-password
gcloud secrets versions access latest --secret=elevia-nextauth-secret

# View Cloud SQL logs
gcloud sql operations list --instance=elevia-postgres-xxxx

# Test VPC connectivity from Cloud Run
gcloud run jobs create test-connection \
  --image=gcr.io/google.com/cloudsdktool/cloud-sdk:latest \
  --task-timeout=300 \
  --command=sh \
  --args="-c","apt-get update && apt-get install -y postgresql-client && psql postgresql://USER:PASS@PRIVATE_IP:5432/DATABASE -c 'SELECT NOW();'"

# View Terraform state
terraform show

# Monitor live workflow execution
gh run watch <run-id>

# Check workflow file differences
git diff HEAD~1 .github/workflows/deploy.yml
```

## Security Considerations

- **Secret Management**: Database passwords and NextAuth secrets stored in Google Secret Manager
- **Network Security**: Cloud SQL uses private IP with VPC-only access
- **No Service Account Keys**: Workload Identity Federation eliminates long-lived keys
- **Runtime Security**: Secrets injected at runtime, never stored in code or containers
- **HTTPS Only**: All traffic to Cloud Run is automatically HTTPS
- **IAM Principle of Least Privilege**: Cloud Run service account has minimal required permissions
- **Regular Updates**: Automated security updates via CI/CD pipeline

### Secret Manager Security
- Secrets are encrypted at rest and in transit
- Access logs available for audit
- Version management for secret rotation
- Cloud Run service account requires explicit `secretmanager.secretAccessor` permission

## Cost Optimization

- Cloud Run scales to zero when not in use
- Cloud SQL uses smallest instance size (db-f1-micro) by default
- Terraform state includes deletion protection for production data
- Consider upgrading to larger instances for production workloads

## Environment Configuration Details

### Production Environment Variables (Cloud Run)

The following environment variables are automatically configured by Terraform:

```bash
# Set by Terraform
NODE_ENV=production
CLOUD_SQL_CONNECTION_NAME=project:region:instance  # From terraform output
DB_NAME=elevia_db
DB_USER=elevia_user
NEXTAUTH_URL=https://your-cloud-run-url

# Injected from Secret Manager
DB_PASS=***  # From Secret Manager secret: elevia-db-password
AUTH_SECRET=***  # From Secret Manager secret: elevia-nextauth-secret

# Cloud Run specific
K_SERVICE=elevia  # Automatically set by Cloud Run
```

### Development Environment Variables (.env.local)

```bash
# Required for development
CLOUD_SQL_CONNECTION_NAME=project:region:instance  # From terraform output
DB_USER=elevia_user
DB_PASS=your-local-password  # Same as Terraform variable
DB_NAME=elevia_db
NEXTAUTH_URL=http://localhost:3000
AUTH_SECRET=your-32-char-secret  # Same as Terraform variable

# Optional
DB_HOST=127.0.0.1  # For Cloud SQL Proxy
DB_PORT=5432
```

### Environment Detection Logic

The application automatically detects the environment:

```typescript
const isProduction = process.env.NODE_ENV === 'production';
const isCloudRun = process.env.K_SERVICE !== undefined;

if (isProduction && isCloudRun) {
  // Use VPC direct connection
} else {
  // Use Cloud SQL Connector
}
```

For additional support, refer to the Google Cloud documentation or open an issue in the repository.

---

## Summary: CI/CD-First Deployment Architecture

### ðŸŽ¯ Design Philosophy

This deployment uses a **CI/CD-first approach** where:

- âœ… **Infrastructure as Code**: Terraform with proper timeout and dependency management
- âœ… **Automated Deployment**: GitHub Actions handles all deployment steps
- âœ… **Security**: Direct Workload Identity Federation (no service account keys)
- âœ… **Zero-Downtime**: Cloud Run with rolling deployments
- âœ… **Production-Ready**: VPC networking, Secret Manager, private databases

### ðŸ”§ Technical Improvements Applied

**Terraform Configuration**:
- **30-minute timeouts** for Cloud SQL operations (handles 15-20 minute creation time)
- **Explicit dependencies** prevent resource creation race conditions
- **Correct API names** (`sqladmin.googleapis.com` instead of `cloudsql.googleapis.com`)
- **Direct Workload Identity Federation** for secure GitHub Actions authentication

**Application Architecture**:
- **Cloud Run** with VPC connector for private database access
- **Secret Manager** for credential management (no environment variables)
- **Artifact Registry** for container images
- **Automatic scaling** from 0 to 10 instances

### ðŸš€ Next Steps

1. **Setup GitHub Actions workflows** (see next section)
2. **Push to main branch** to trigger automated deployment
3. **Monitor deployment** through GitHub Actions logs
4. **Access application** via automatically generated Cloud Run URL

The entire infrastructure and application stack deploys automatically with a single git push.

### ðŸ”„ CI/CD Improvement Lessons

Based on real deployment troubleshooting experience, the following improvements have been applied:

#### Configuration Consistency
- **Naming Convention Alignment**: Terraform state bucket naming now consistent between `init.sh` and `deploy.yml`
- **Resource Naming Standards**: All Terraform resources use predictable naming patterns
- **Variable Scope Clarity**: Clear distinction between repository variables and environment secrets

#### Debugging Enhancement
- **Systematic Error Analysis**: Step-by-step debugging approach for CI/CD failures
- **Common Error Patterns**: Documented authentication, permission, and resource issues
- **Prevention Measures**: Proactive checks to avoid common configuration mismatches

#### Deployment Resilience
- **Timeout Management**: 30-minute timeouts for Cloud SQL operations
- **Dependency Management**: Explicit resource dependencies prevent race conditions
- **Error Recovery**: Clear recovery procedures for common deployment failures

#### Future Improvements
Consider implementing these enhancements:
- **Pre-deployment Validation**: Automated checks for configuration consistency
- **Deployment Health Checks**: Post-deployment validation of service functionality
- **Rollback Procedures**: Automated rollback for failed deployments
- **Environment Parity**: Ensure staging environment matches production configuration